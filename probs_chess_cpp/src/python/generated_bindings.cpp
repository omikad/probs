// This file is AUTOGENERATED, do not edit.
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include "python/definitions.h"

namespace {
PyObject *TLczeroExceptionExceptionType;
struct TChessEnvClassType;
extern PyTypeObject objChessEnvClassType;
struct TChessEnvClassType {
  PyObject_HEAD
  probs::python::ChessEnv *value;
};

PyObject* FChessEnvMethodlegal_moves(TChessEnvClassType* self, PyObject* /* not used */) {
  PyObject *retval;
  std::vector<std::string> retval_cpp = self->value->legal_moves();
  retval = PyList_New(retval_cpp.size());
  for (size_t i = 0; i < retval_cpp.size(); ++i) {
    const std::string& s = retval_cpp[i];
    PyList_SetItem(retval, i, Py_BuildValue("s#", s.data(), s.size()));
  }
  return retval;
}

PyObject* FChessEnvMethodmove(TChessEnvClassType* self, PyObject *args, PyObject *kwargs) {
  const char* move = nullptr;
  Py_ssize_t move_len = 0;
  const char* keywords[] = {"move", nullptr};
  if (!PyArg_ParseTupleAndKeywords(args,
      kwargs,
      "|z#",
      const_cast<char**>(keywords),
      &move,
      &move_len)) {
    return nullptr;
  }
  std::optional<std::string> move_cpp;
  if (move != nullptr) move_cpp.emplace(move, move_len);
  self->value->move(move_cpp);
  return Py_BuildValue("");
}

PyObject* FChessEnvMethodgame_state(TChessEnvClassType* self, PyObject* /* not used */) {
  PyObject *retval;
  const std::string& retval_cpp = self->value->game_state();
  retval = Py_BuildValue("s#", retval_cpp.data(), retval_cpp.size());
  return retval;
}

PyObject* FChessEnvMethodpolicy_indices(TChessEnvClassType* self, PyObject* /* not used */) {
  PyObject *retval;
  std::vector<int> retval_cpp = self->value->policy_indices();
  retval = PyTuple_New(retval_cpp.size());
  for (size_t i = 0; i < retval_cpp.size(); ++i) {
    PyTuple_SetItem(retval, i, Py_BuildValue("i", retval_cpp[i]));
  }
  return retval;
}

PyObject* FChessEnvMethodas_string(TChessEnvClassType* self, PyObject* /* not used */) {
  PyObject *retval;
  const std::string& retval_cpp = self->value->as_string();
  retval = Py_BuildValue("s#", retval_cpp.data(), retval_cpp.size());
  return retval;
}

PyMethodDef rgChessEnvClassFunctions[] = {
  {"legal_moves", reinterpret_cast<PyCFunction>(&FChessEnvMethodlegal_moves), METH_NOARGS, nullptr},
  {"move", reinterpret_cast<PyCFunction>(&FChessEnvMethodmove), METH_VARARGS | METH_KEYWORDS, nullptr},
  {"game_state", reinterpret_cast<PyCFunction>(&FChessEnvMethodgame_state), METH_NOARGS, nullptr},
  {"policy_indices", reinterpret_cast<PyCFunction>(&FChessEnvMethodpolicy_indices), METH_NOARGS, nullptr},
  {"as_string", reinterpret_cast<PyCFunction>(&FChessEnvMethodas_string), METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

int FChessEnvConstructor(TChessEnvClassType* self, PyObject *args, PyObject *kwargs) {
  const char* fen = nullptr;
  Py_ssize_t fen_len = 0;
  int max_ply = 0;
  const char* keywords[] = {"fen", "max_ply", nullptr};
  if (!PyArg_ParseTupleAndKeywords(args,
      kwargs,
      "|z#i",
      const_cast<char**>(keywords),
      &fen,
      &fen_len,
      &max_ply)) {
    return -1;
  }
  std::optional<std::string> fen_cpp;
  if (fen != nullptr) fen_cpp.emplace(fen, fen_len);
  try {
    self->value = new probs::python::ChessEnv(fen_cpp, max_ply);
  } catch (const lczero::Exception &ex) {
    PyErr_SetString(TLczeroExceptionExceptionType, ex.what());
    return -1;
  }
  return 0;
}

void FChessEnvDestructor(TChessEnvClassType* self) {
  delete self->value;
  Py_TYPE(self)->tp_free(&self->ob_base);
}

PyTypeObject objChessEnvClassType = {
  .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
  .tp_name = "libprobs_chess.ChessEnv",
  .tp_basicsize = sizeof(TChessEnvClassType),
  .tp_dealloc = reinterpret_cast<destructor>(FChessEnvDestructor),
  .tp_flags = Py_TPFLAGS_DEFAULT,
  .tp_doc = nullptr,
  .tp_methods = rgChessEnvClassFunctions,
  .tp_init = reinterpret_cast<initproc>(FChessEnvConstructor),
  .tp_alloc = PyType_GenericAlloc,
  .tp_new = PyType_GenericNew,
};
PyMethodDef rglibprobs_chessModuleFunctions[] = {
  {nullptr, nullptr, 0, nullptr}
};

PyModuleDef Tlibprobs_chessModule = {
  PyModuleDef_HEAD_INIT,
  "libprobs_chess",
  nullptr,
  -1,
  rglibprobs_chessModuleFunctions,
  nullptr, nullptr, nullptr, nullptr, 
};
}  // anonymous namespace

PyMODINIT_FUNC PyInit_libprobs_chess() {
  lczero::InitializeMagicBitboards();

  PyObject* module = PyModule_Create(&Tlibprobs_chessModule);
  if (module == nullptr) return nullptr;
  TLczeroExceptionExceptionType = PyErr_NewException("libprobs_chess.LczeroException", nullptr, nullptr);
  if (TLczeroExceptionExceptionType == nullptr) return nullptr;
  Py_INCREF(TLczeroExceptionExceptionType);
  PyModule_AddObject(module, "LczeroException", TLczeroExceptionExceptionType);
  if (PyType_Ready(&objChessEnvClassType) != 0) return nullptr;
  PyModule_AddObject(module, "ChessEnv", &objChessEnvClassType.ob_base.ob_base);
  return module;
}
